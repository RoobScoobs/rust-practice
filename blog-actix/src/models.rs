/*** 
 *
   MODELS MODULE

   To define the Rust representation of our data model as represented by our database

   As we're working with the database, we need to pull in the Diesel prelude and
   also bring in the users item from the autogenerated schema

   ALIAS TYPE

   We'll define our own Result type
   which will be an alias for Result in the standard library
   with the error type fixed as our AppError type

   This way we can just return Result<T> and not have to write AppError everywhere

   USERS STRUCT

   Our users have ids which are i32 because that maps to the database integer type
   and a username which is a String because the database column is a VARCHAR

   DERIVABLE TRAITS

   Queryable is a trait that indicates this struct can be constructed from a database query

   From the docs:
      Diesel represents the return type of a query as a tuple.
      The purpose of this trait is to convert from a tuple of Rust values that have been deserialized into your struct

   Identifiable is a trait that indicates that this struct represents a single row in a database table.
   
   It assumes a primary key named id
   but you can configure the derive attribute
   if you want to change the name of the primary key

   CREATE USER

   create_user function takes a SqliteConnection and a username string
   and returns either a User or an error

   Sqlite does not support getting the id of a just inserted row as part of the insert statement.
   Instead we have to do another query to actually get the data back out to build a User struct

   The connection type supports a method transaction which takes a closure.
   The closure must return a Result.

   If the Result is the error variant
   then the transaction is rolled back and
   the error result is returned

   If instead we have the Ok variant
   then the transaction is committed and
   the successful result is returned.

   FIRST DIESEL STATEMENT

   The imported users item from the schema has an item for each column on the table
   as well as an item for the table as a whole, i.e. users::table

   Each database column has a unique type so you catch at compile time
   if you tried to insert the wrong type into a column rather than at runtime.

   The execute method on the query builder returns a Result with the error being the Diesel specific error type.
   We can use the ? operator here and return a Result with our AppError error type
   because of our From implementation in our errors module

   SECOND STATEMENT INSIDE THE TRANSANCTION

   We're fetching a single user from the database.
   We create a query where we order by descending id to get the most recently inserted row

   As this is inside a transaction this select will execute logically after the insertion
   and therefore this will be the user we just inserted

   We specify with the select method what columns we want in a tuple,
   in this case id and username

   The first method tells Diesel to do a LIMIT 1 and expect a single result

   This therefore returns a Result with the successful variant being the resulting record or a not found error

   The return type of our function is what gives Diesel enough information to convert the tuple
   that is returned into our User struct in addition to the fact that we derived Queryable.

   Finally we call map_err, which is a method on Result that helps transform the error variant
   with the supplied funciton and returns the success variant as is.
   
   We cannot use the ? operator here to return our Result
   as we have to explicitly convert the Diesel error type to our AppError to match the function signature

   We can pass the function Into::into to map_err and
   this uses the function signature to determine what to transform the error into.
   
   Furthermore, we can use Into here because we implemented From and Into gets implemented automatically.

   FETCHING A USER

   Two ways to identify a user: by id and by username

   The UserKey enum is either an ID which holds an i32 for looking up by the primary key or
   a Username which holds a reference to a string

   GENERIC LIFETIME FOR A TYPE
   
   Lifetimes of references in Rust are checked by the compiler to ensure
   that the data referenced outlives the reference to it

   Here our type UserKey<'a> specifies that it has one generic lifetime parameter named 'a

   We need to specify this generic parameter
   so that we can give a definite lifetime to the string reference inside our Username variant

   In other words, we need to ensure that any reference to a UserKey
   cannot outlive the reference to the string slice it contains

   Any composite type with a reference inside must declare a lifetime on that reference
   otherwise there is no way for the compiler to make any guarantees about the liveness of the underlying data

   FUNCTION WHICH GETS THE USER find_user

   We match on our key to decide which query to run.
   
   If we have a username,
   then we do a filter by username equal to the value passed in.
   
   If we have an id,
   then we can use the special find function
   which attempts to find a single record based on the primary key for that table

   POST MODEL

   Our database schema is directly translated to Rust types where each field is a column of the appropriate type

   Note that the not null constraints we specified in our migration on each column is why we use types directly
   rather than wrapping them in Option

   ASSOCIATION

   The concept of an association in Diesel is always from child to parent

   Declaring the association between two records requires the belongs_to attribute on the child
   and specifies the name of the struct that represents the parent

   The belongs_to attribute accepts a foreign_key argument
   if the relevant foreign key is different from table_name_id
   
   Both the parent and child must implement the Identifiable trait

   In addition to the belongs_to annotation,
   the struct also needs to derive Associations
   
   Deriving this trait uses the information in belongs_to to generate the relevant code to make joins possible

   CREATING A POST

   Code for inserting into the posts table
   and then fetching the post is very similar to that for a user

   The use of select(posts::all_columns) which is a shorthand that Diesel provides
   prevents writing out a tuple with each column explicitly listed
   Depending on the struct you are serializing to you may or may not be able to use this shorthand

   PUBLISH A POST

   The create_post method uses the database default for the published column and
   therefore in order to set published to true we need to update the database row for a particular post

   Issuing an update to the database uses the aptly named update function from Diesel

   The argument to update can be a table, a filtered table (which is what we use here),
   or a reference to a struct that implements the Identifiable trait

   If you pass just a table then the update applies to all rows of that table which is typically not what you want

   We are only updating a single column so we pass one expression to the set method,
   but if you want to update multiple columns you can pass a tuple to set instead

   RETRIEVING POSTS

   Implementing two different ways of retrieving posts
      - to get all published posts
      - to get only those posts written by a particular user

   The all_posts function returns a list of tuples where the first element is a post
   and the second element is the author

   Diesel is built around queries that have this flat result structure

   We order the posts based on their id as this will make them newest first

   We also select only those posts which have been published

   For each post we want to fetch all of the data about the post as well as data about the author
   so we use a query (inner_join) involving multiple tables (i.e. the posts and users table)

   Diesel will figure out how to perform the join based on the association attributes we put on the Post model

   The argument to select is a tuple with two elements both of which are tuples representing the columns we want to fetch
   We then tell load the type to coerce these columns into

   user_posts takes the user_id as input and retrieves a vector of posts or an empty set if the user does not exist

   COMMENT MODEL

   Quite similar to our Post struct except we have an extra belongs_to attribute for the User and Post associations
   
   FETCHING ALL THE COMMENTS FROM A POST

   The returned result should contain the user who made the comment, along with the comment
   The post is unnecessary as it is known 

   FETCHING ALL COMMENTS BY A USER

   Notable information to include would be the post the comment is on,
   however fetching all of the post data would be excessive
   so a new struct
         PostWithComment {}
   can be made to represent the subset of the post data

   The struct derives Queryable but not Identifiable
   It can be constructed from a query,
   but it does not represent an entire row in a table

   The user_comments function filters the comments table based on the passed in user_id
   and then joins with the posts data to get the extra information about the posts

   Using the select method narrows down which columns from the posts table we need to construct our PostWithComment struct
   and then load a tuple (Comment and PostWithComment) which results in getting the return type we want

   REVISING THE POST FETCHING FUNCTIONS

   By changing the result form of
      Vec<(Post,User)>
            to
      Vec<((Post, User), Vec<(Comment, User)>)>

   it will include not only the post and its author/user but also a vector of comments with their respective author/user

   Modifying the all_posts function to perform the same query as before
   which gets all posts and their corresponding authors 

      let posts_with_user = query.load::<(Post, User)>(conn)?;

   Then using the unzip method on std::iter::Iterator turns an iterator of pairs into a pair of iterators aka able to turn
      Vec<(Post, User)> into (Vec<Post>, Vec<User>)

   Can then fetch all of the comments that belong to those posts
   by passing a reference to that vector to belonging_to which we get from deriving Associations on Comment

   To associate the comments into chunks indexed by the posts we use the grouped_by method provided by Diesel
   In the end this transforms a Vec<(Comment, User)> into Vec<Vec<(Comment, User)>>

   Finally use the zip method on iterator to take all of these vectors
   and combine them into the output format we're looking for

   posts.into_iter().zip(post_users) just turns (Vec<Post>, Vec<User>) back into Vec<(Post, User)>

   The last zip(comments) takes Vec<(Post, User)> and Vec<Vec<(Comment, User)>>
   and puts them together into a single vector of our desired return type
 *
***/

use crate::errors::AppError;
use crate::schema::{
   users,
   posts,
   comments
};
use diesel::prelude::*;

type Result<T> = std::result::Result<T, AppError>;

#[derive(Queryable, Identifiable, Serialize, Debug, PartialEq)]
pub struct User {
   pub id: i32,
   pub username: String,
}

#[derive(Queryable, Associations, Identifiable, Serialize, Debug)]
#[belongs_to(User)]
pub struct Post {
   pub id: i32,
   pub user_id: i32,
   pub title: String,
   pub body: String,
   pub published: bool,
}

#[derive(Queryable, Associations, Identifiable, Serialize, Debug)]
#[belongs_to(User)]
#[belongs_to(Post)]
pub struct Comment {
   pub id: i32,
   pub user_id: i32,
   pub post_id: i32,
   pub body: String,
}

#[derive(Queryable, Serialize, Debug)]
pub struct PostWithComment {
   pub id: i32,
   pub title: String,
   pub published: bool,
}

pub enum UserKey<'a> {
   Username(&'a str),
   ID(i32),
}

pub fn create_user(conn: &SqliteConnection, username: &str) -> Result<User> {
   conn.transaction(|| {
      diesel::insert_into(users::table)
         .values((users::username.eq(username),))
         .execute(conn)?;

      users::table
         .order(users::id.desc())
         .select((users::id, users::username))
         .first(conn)
         .map_err(Into::into)
   })
}

pub fn find_user<'a>(conn: &SqliteConnection, key: UserKey<'a>) -> Result<User> {
   match key {
      UserKey::Username(name) => users::table
         .filter(users::username.eq(name))
         .select((users::id, users::username))
         .first::<User>(conn)
         .map_err(AppError::from),

      UserKey::ID(id) => users::table
         .find(id)
         .select((users::id, users::username))
         .first::<User>(conn)
         .map_err(Into::into),
   }
}

pub fn create_post(
   conn: &SqliteConnection,
   user: &User,
   title: &str,
   body: &str
) -> Result<Post> {
   conn.transaction(|| {
      diesel::insert_into(posts::table)
         .values((
            posts::user_id.eq(user.id),
            posts::title.eq(title),
            posts::body.eq(body),
         ))
         .execute(conn)?;

      posts::table
         .order(posts::id.desc())
         .select(posts::all_columns)
         .first(conn)
         .map_err(Into::into)
   })
}

pub fn publish_post(conn: &SqliteConnection, post_id: i32) -> Result<Post> {
   conn.transaction(|| {
      diesel::update(posts::table.filter(posts::id.eq(post_id)))
         .set(posts::published.eq(true))
         .execute(conn)?;

      posts::table
         .find(post_id)
         .select(posts::all_columns)
         .first(conn)
         .map_err(Into::into)
   })
}

pub fn all_posts(conn: &SqliteConnection) -> Result<Vec<((Post, User), Vec<(Comment, User)>)>> {
   let query = posts::table
      .order(posts::id.desc())
      .filter(posts::published.eq(true))
      .inner_join(users::table)
      .select((posts::all_columns, (users::id, users::username)));

   let posts_with_user = query.load::<(Post, User)>(conn)?;

   let (posts, post_users): (Vec<_>, Vec<_>) = posts_with_user.into_iter().unzip();

   let comments = Comment::belonging_to(&posts)
      .inner_join(users::table)
      .select((comments::all_columns, (users::id, users::username)))
      .load::<(Comment, User)>(conn)?
      .grouped_by(&posts);

   Ok(posts.into_iter().zip(post_users).zip(comments).collect())
}

pub fn user_posts(
   conn: &SqliteConnection,
   user_id: i32
) -> Result<Vec<(Post, Vec<(Comment, User)>)>> {
   let posts::table
      .filter(posts::user_id.eq(user_id))
      .order(posts::id.desc())
      .select(posts::all_columns)
      .load::<Post>(conn)?;

   let comments = Comment::belonging_to(&posts)
      .inner_join(users::table)
      .select((comments::all_columns, (users::id, users::username)))
      .load::<(Comment, User)>(conn)?
      .grouped_by(&posts);

   Ok(posts.into_iter().zip(comments).collect())
}

pub fn create_comment(
   conn: &SqliteConnection,
   user_id: i32,
   post_id: i32,
   body: &str
) -> Result<Comment> {
   conn.transaction(|| {
      diesel::insert_into(comments::table)
         .values((
            comments::user_id.eq(user_id),
            comments::post_id.eq(post_id),
            comments::body.eq(body),
         ))
         .execute(conn)?;

      comments::table
         .order(comments::id.desc())
         .select(comments::all_columns)
         .first(conn)
         .map_err(Into::into)
   })
}

pub fn post_comments(conn: &SqliteConnection, post_id: i32) -> Result<Vec<(Comment, User)>> {
   comments::table
      .filter(comments::post_id.eq(post_id))
      .inner_join(users::table)
      .select((comments::all_columns, (users::id, users::username)))
      .load::<(Comment, User)>(conn)
      .map_err(Into::into)
}

pub fn user_comments(
   conn: &SqliteConnection,
   user_id: i32
) -> Result<Vec<(Comment, PostWithComment)>> {
   comments::table
      .filter(comments::user_id.eq(user_id))
      .inner_join(posts::table)
      .select((
         comments::all_columns,
         (posts::id, posts::title, posts::published)
      ))
      .load::<(Comment, PostWithComment)>(conn)
      .map_err(Into::into)
}